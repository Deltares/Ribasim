from enum import Enum

from pydantic import Field

from ribasim.geometry import BasinAreaSchema, FlowBoundaryAreaSchema
from ribasim.geometry.node import NodeModel
from ribasim.input_base import (
    ChildModel,
    SpatialTableModel,
    TableModel,
)

# These schemas are autogenerated
from ribasim.schemas import (
    BasinConcentrationExternalSchema,
    BasinConcentrationSchema,
    BasinConcentrationStateSchema,
    BasinProfileSchema,
    BasinStateSchema,
    BasinStaticSchema,
    BasinSubgridSchema,
    BasinSubgridTimeSchema,
    BasinTimeSchema,
    ContinuousControlFunctionSchema,
    ContinuousControlVariableSchema,
    DiscreteControlConditionSchema,
    DiscreteControlLogicSchema,
    DiscreteControlVariableSchema,
    FlowBoundaryConcentrationSchema,
    FlowBoundaryStaticSchema,
    FlowBoundaryTimeSchema,
    FlowDemandStaticSchema,
    FlowDemandTimeSchema,
    LevelBoundaryConcentrationSchema,
    LevelBoundaryStaticSchema,
    LevelBoundaryTimeSchema,
    LevelDemandStaticSchema,
    LevelDemandTimeSchema,
    LinearResistanceStaticSchema,
    ManningResistanceStaticSchema,
    OutletStaticSchema,
    OutletTimeSchema,
    PidControlStaticSchema,
    PidControlTimeSchema,
    PumpStaticSchema,
    PumpTimeSchema,
    TabulatedRatingCurveStaticSchema,
    TabulatedRatingCurveTimeSchema,
    UserDemandConcentrationSchema,
    UserDemandStaticSchema,
    UserDemandTimeSchema,
)


class RoutePriority(ChildModel):
    """Specify per node type what its default route priority is."""

    level_boundary: int = 1000
    basin: int = 2000
    manning_resistance: int = 10
    linear_resistance: int = 20
    tabulated_rating_curve: int = 30
    outlet: int = 40
    pump: int = 50


class Interpolation(ChildModel):
    """
    Defines interpolation types used for various node types.

    Supported interpolation types are: linear, block

    Attributes
    ----------
    flow_boundary : string
        The interpolation type used for the flow rate timeseries (optional, defaults to 'block')
    block_transition_period : float
        If block interpolation is used, this is the maximum time span on either side of the data points over which
        the transition between data points is smoothed.
    """

    flow_boundary: str = "block"
    block_transition_period: float = 0.0


class Allocation(ChildModel):
    """
    Defines the allocation optimization algorithm options.

    Attributes
    ----------
    timestep : float
        The simulated time in seconds between successive allocation calls (Optional, defaults to 86400)
    """

    timestep: float = 86400.0
    default_route_priority: RoutePriority = RoutePriority()


class Results(ChildModel):
    format: str = "netcdf"
    compression: bool = True
    compression_level: int = 6
    subgrid: bool = False


class Solver(ChildModel):
    """
    Defines the numerical solver options.

    For more details see <https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/#solver_options>.

    Attributes
    ----------
    algorithm : str
        The used numerical time integration algorithm (Optional, defaults to QNDF)
    saveat : float
        Time interval in seconds between saves of output data.
        0 saves every timestep, inf only saves at start- and endtime. (Optional, defaults to 86400)
    dt : float
        Timestep of the solver. (Optional, defaults to None which implies adaptive timestepping)
    dtmin : float
        The minimum allowed timestep of the solver (Optional, defaults to 0.0)
    dtmax : float
        The maximum allowed timestep size (Optional, defaults to 0.0 which implies the total length of the simulation)
    force_dtmin : bool
        If a smaller dt than dtmin is needed to meet the set error tolerances, the simulation stops, unless force_dtmin = true
        (Optional, defaults to False)
    abstol : float
        The absolute tolerance for adaptive timestepping (Optional, defaults to 1e-7)
    reltol : float
        The relative tolerance for adaptive timestepping (Optional, defaults to 1e-7)
    maxiters : int
        The total number of linear iterations over the whole simulation. (Defaults to 1e9, only needs to be increased for extremely long simulations)
    sparse : bool
        Whether a sparse Jacobian matrix is used, which gives a significant speedup for models with >~10 basins.
    autodiff : bool
        Whether automatic differentiation instead of fine difference is used to compute the Jacobian. (Optional, defaults to true)
    depth_threshold : float
        Universal depth at which the low storage factor kicks in
    level_difference_threshold : float
        Universal reduction factor threshold for the level difference of Pump/Outlet and TabulatedRatingCurve nodes
    evaporate_mass : bool
        Whether mass is lost due to evaporation in water quality calculations. (Optional, defaults to true)
    specialize : bool
        Trades initialization speed for simulation speed, useful for long-running simulations. (Optional, defaults to false)
    """

    algorithm: str = "QNDF"
    saveat: float = 86400.0
    dt: float | None = None
    dtmin: float | None = None
    dtmax: float | None = None
    force_dtmin: bool = False
    abstol: float = 1e-06
    reltol: float = 1e-05
    maxiters: int = 1000000000
    sparse: bool = True
    autodiff: bool = True
    evaporate_mass: bool = True
    depth_threshold: float = 0.1
    level_difference_threshold: float = 0.02
    specialize: bool = False


class Verbosity(str, Enum):
    debug = "debug"
    info = "info"
    warn = "warn"
    error = "error"


class Logging(ChildModel):
    """
    Defines the logging behavior of the core.

    Attributes
    ----------
    verbosity : Verbosity
        The verbosity of the logging: debug/info/warn/error (Optional, defaults to info)
    """

    verbosity: Verbosity = Verbosity.info


class Experimental(ChildModel):
    """
    Defines experimental features.

    Attributes
    ----------
    concentration : bool
        Whether to enable tracer support (default is False)
    allocation : bool
        Whether to activate the activation layer. Replaced by 'first come first serve' when deactivated (default is False)
    """

    concentration: bool = False
    allocation: bool = False


class Terminal(NodeModel): ...


class Junction(NodeModel): ...


class PidControl(NodeModel):
    static: TableModel[PidControlStaticSchema] = Field(
        default_factory=TableModel[PidControlStaticSchema],
        json_schema_extra={"sort_keys": ["node_id", "control_state"]},
    )
    time: TableModel[PidControlTimeSchema] = Field(
        default_factory=TableModel[PidControlTimeSchema],
        json_schema_extra={"sort_keys": ["node_id", "time"]},
    )


class LevelBoundary(NodeModel):
    static: TableModel[LevelBoundaryStaticSchema] = Field(
        default_factory=TableModel[LevelBoundaryStaticSchema],
        json_schema_extra={"sort_keys": ["node_id"]},
    )
    time: TableModel[LevelBoundaryTimeSchema] = Field(
        default_factory=TableModel[LevelBoundaryTimeSchema],
        json_schema_extra={"sort_keys": ["node_id", "time"]},
    )
    concentration: TableModel[LevelBoundaryConcentrationSchema] = Field(
        default_factory=TableModel[LevelBoundaryConcentrationSchema],
        json_schema_extra={"sort_keys": ["node_id", "substance", "time"]},
    )


class Pump(NodeModel):
    static: TableModel[PumpStaticSchema] = Field(
        default_factory=TableModel[PumpStaticSchema],
        json_schema_extra={"sort_keys": ["node_id", "control_state"]},
    )
    time: TableModel[PumpTimeSchema] = Field(
        default_factory=TableModel[PumpTimeSchema],
        json_schema_extra={"sort_keys": ["node_id", "time"]},
    )


class TabulatedRatingCurve(NodeModel):
    static: TableModel[TabulatedRatingCurveStaticSchema] = Field(
        default_factory=TableModel[TabulatedRatingCurveStaticSchema],
        json_schema_extra={"sort_keys": ["node_id", "control_state", "level"]},
    )
    time: TableModel[TabulatedRatingCurveTimeSchema] = Field(
        default_factory=TableModel[TabulatedRatingCurveTimeSchema],
        json_schema_extra={"sort_keys": ["node_id", "time", "level"]},
    )


class UserDemand(NodeModel):
    static: TableModel[UserDemandStaticSchema] = Field(
        default_factory=TableModel[UserDemandStaticSchema],
        json_schema_extra={"sort_keys": ["node_id", "demand_priority"]},
    )
    time: TableModel[UserDemandTimeSchema] = Field(
        default_factory=TableModel[UserDemandTimeSchema],
        json_schema_extra={"sort_keys": ["node_id", "demand_priority", "time"]},
    )
    concentration: TableModel[UserDemandConcentrationSchema] = Field(
        default_factory=TableModel[UserDemandConcentrationSchema],
        json_schema_extra={"sort_keys": ["node_id", "substance", "time"]},
    )


class LevelDemand(NodeModel):
    static: TableModel[LevelDemandStaticSchema] = Field(
        default_factory=TableModel[LevelDemandStaticSchema],
        json_schema_extra={"sort_keys": ["node_id", "demand_priority"]},
    )
    time: TableModel[LevelDemandTimeSchema] = Field(
        default_factory=TableModel[LevelDemandTimeSchema],
        json_schema_extra={"sort_keys": ["node_id", "demand_priority", "time"]},
    )


class FlowBoundary(NodeModel):
    static: TableModel[FlowBoundaryStaticSchema] = Field(
        default_factory=TableModel[FlowBoundaryStaticSchema],
        json_schema_extra={"sort_keys": ["node_id"]},
    )
    time: TableModel[FlowBoundaryTimeSchema] = Field(
        default_factory=TableModel[FlowBoundaryTimeSchema],
        json_schema_extra={"sort_keys": ["node_id", "time"]},
    )
    concentration: TableModel[FlowBoundaryConcentrationSchema] = Field(
        default_factory=TableModel[FlowBoundaryConcentrationSchema],
        json_schema_extra={"sort_keys": ["node_id", "substance", "time"]},
    )
    area: SpatialTableModel[FlowBoundaryAreaSchema] = Field(
        default_factory=SpatialTableModel[FlowBoundaryAreaSchema],
        json_schema_extra={"sort_keys": ["node_id"]},
    )


class FlowDemand(NodeModel):
    static: TableModel[FlowDemandStaticSchema] = Field(
        default_factory=TableModel[FlowDemandStaticSchema],
        json_schema_extra={"sort_keys": ["node_id", "demand_priority"]},
    )
    time: TableModel[FlowDemandTimeSchema] = Field(
        default_factory=TableModel[FlowDemandTimeSchema],
        json_schema_extra={"sort_keys": ["node_id", "demand_priority", "time"]},
    )


class Basin(NodeModel):
    profile: TableModel[BasinProfileSchema] = Field(
        default_factory=TableModel[BasinProfileSchema],
        json_schema_extra={"sort_keys": ["node_id", "level"]},
    )
    state: TableModel[BasinStateSchema] = Field(
        default_factory=TableModel[BasinStateSchema],
        json_schema_extra={"sort_keys": ["node_id"]},
    )
    static: TableModel[BasinStaticSchema] = Field(
        default_factory=TableModel[BasinStaticSchema],
        json_schema_extra={"sort_keys": ["node_id"]},
    )
    time: TableModel[BasinTimeSchema] = Field(
        default_factory=TableModel[BasinTimeSchema],
        json_schema_extra={"sort_keys": ["node_id", "time"]},
    )
    subgrid: TableModel[BasinSubgridSchema] = Field(
        default_factory=TableModel[BasinSubgridSchema],
        json_schema_extra={"sort_keys": ["subgrid_id", "basin_level"]},
    )
    subgrid_time: TableModel[BasinSubgridTimeSchema] = Field(
        default_factory=TableModel[BasinSubgridTimeSchema],
        json_schema_extra={"sort_keys": ["subgrid_id", "time", "basin_level"]},
    )
    area: SpatialTableModel[BasinAreaSchema] = Field(
        default_factory=SpatialTableModel[BasinAreaSchema],
        json_schema_extra={"sort_keys": ["node_id"]},
    )
    concentration: TableModel[BasinConcentrationSchema] = Field(
        default_factory=TableModel[BasinConcentrationSchema],
        json_schema_extra={"sort_keys": ["node_id", "substance", "time"]},
    )
    concentration_external: TableModel[BasinConcentrationExternalSchema] = Field(
        default_factory=TableModel[BasinConcentrationExternalSchema],
        json_schema_extra={"sort_keys": ["node_id", "substance", "time"]},
    )
    concentration_state: TableModel[BasinConcentrationStateSchema] = Field(
        default_factory=TableModel[BasinConcentrationStateSchema],
        json_schema_extra={"sort_keys": ["node_id", "substance"]},
    )


class ManningResistance(NodeModel):
    static: TableModel[ManningResistanceStaticSchema] = Field(
        default_factory=TableModel[ManningResistanceStaticSchema],
        json_schema_extra={"sort_keys": ["node_id", "control_state"]},
    )


class DiscreteControl(NodeModel):
    variable: TableModel[DiscreteControlVariableSchema] = Field(
        default_factory=TableModel[DiscreteControlVariableSchema],
        json_schema_extra={
            "sort_keys": [
                "node_id",
                "compound_variable_id",
                "listen_node_id",
                "variable",
            ]
        },
    )
    condition: TableModel[DiscreteControlConditionSchema] = Field(
        default_factory=TableModel[DiscreteControlConditionSchema],
        json_schema_extra={
            "sort_keys": ["node_id", "compound_variable_id", "condition_id"]
        },
    )
    logic: TableModel[DiscreteControlLogicSchema] = Field(
        default_factory=TableModel[DiscreteControlLogicSchema],
        json_schema_extra={"sort_keys": ["node_id", "truth_state"]},
    )


class Outlet(NodeModel):
    static: TableModel[OutletStaticSchema] = Field(
        default_factory=TableModel[OutletStaticSchema],
        json_schema_extra={"sort_keys": ["node_id", "control_state"]},
    )
    time: TableModel[OutletTimeSchema] = Field(
        default_factory=TableModel[OutletTimeSchema],
        json_schema_extra={"sort_keys": ["node_id", "time"]},
    )


class LinearResistance(NodeModel):
    static: TableModel[LinearResistanceStaticSchema] = Field(
        default_factory=TableModel[LinearResistanceStaticSchema],
        json_schema_extra={"sort_keys": ["node_id", "control_state"]},
    )


class ContinuousControl(NodeModel):
    variable: TableModel[ContinuousControlVariableSchema] = Field(
        default_factory=TableModel[ContinuousControlVariableSchema],
        json_schema_extra={"sort_keys": ["node_id", "listen_node_id", "variable"]},
    )
    function: TableModel[ContinuousControlFunctionSchema] = Field(
        default_factory=TableModel[ContinuousControlFunctionSchema],
        json_schema_extra={"sort_keys": ["node_id", "input"]},
    )
